import { __decorate } from 'tslib';
import { ɵɵdefineInjectable, Injectable, Input, Component, NgModule } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { NavigationEnd, PRIMARY_OUTLET, ActivatedRoute, Router, RouterModule } from '@angular/router';
import { filter } from 'rxjs/operators';
import { map } from 'rxjs/internal/operators';
import { CommonModule } from '@angular/common';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatListModule } from '@angular/material/list';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@angular/material/toolbar';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@angular/material/list';

const _c0 = function (a0) { return { "font-size": a0 }; };
const _c1 = function (a0) { return { "color": a0 }; };
function MatBreadcrumbComponent_mat_list_1_span_3_a_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("routerLink", item_r2 == null ? null : item_r2.url)("ngStyle", ɵngcc0.ɵɵpureFunction1(4, _c0, ctx_r4.fontSize))("ngStyle", ɵngcc0.ɵɵpureFunction1(6, _c1, ctx_r4.fontColor));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(item_r2.label);
} }
function MatBreadcrumbComponent_mat_list_1_span_3_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(3, _c0, ctx_r5.fontSize))("ngStyle", ɵngcc0.ɵɵpureFunction1(5, _c1, ctx_r5.lastLinkColor));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(item_r2.label);
} }
function MatBreadcrumbComponent_mat_list_1_span_3_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r6.symbol);
} }
function MatBreadcrumbComponent_mat_list_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, MatBreadcrumbComponent_mat_list_1_span_3_a_1_Template, 2, 8, "a", 5);
    ɵngcc0.ɵɵtemplate(2, MatBreadcrumbComponent_mat_list_1_span_3_span_2_Template, 2, 7, "span", 6);
    ɵngcc0.ɵɵtemplate(3, MatBreadcrumbComponent_mat_list_1_span_3_span_3_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r2 == null ? null : item_r2.url);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !(item_r2 == null ? null : item_r2.url));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.breadcrumb.length !== i_r3 + 1);
} }
function MatBreadcrumbComponent_mat_list_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-list", 2);
    ɵngcc0.ɵɵelementStart(1, "mat-list-item");
    ɵngcc0.ɵɵelementStart(2, "span", 3);
    ɵngcc0.ɵɵtemplate(3, MatBreadcrumbComponent_mat_list_1_span_3_Template, 4, 3, "span", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.breadcrumb);
} }
const _c2 = function (a0) { return { "background-color": a0 }; };
let MatBreadcrumbService = class MatBreadcrumbService {
    constructor() {
        this.breadcrumbLabels = new BehaviorSubject([]);
        this.newBreadcrumb = new BehaviorSubject([]);
    }
    updateBreadcrumbLabels(labels) {
        this.breadcrumbLabels.next(labels);
    }
    updateBreadcrumb(newBreadcrumb) {
        this.newBreadcrumb.next(newBreadcrumb);
    }
};
MatBreadcrumbService.ɵfac = function MatBreadcrumbService_Factory(t) { return new (t || MatBreadcrumbService)(); };
MatBreadcrumbService.ɵprov = ɵɵdefineInjectable({ factory: function MatBreadcrumbService_Factory() { return new MatBreadcrumbService(); }, token: MatBreadcrumbService, providedIn: "root" });

let MatBreadcrumbComponent = class MatBreadcrumbComponent {
    constructor(activatedRoute, router, ng7MatBreadcrumbService) {
        this.activatedRoute = activatedRoute;
        this.router = router;
        this.ng7MatBreadcrumbService = ng7MatBreadcrumbService;
        this.breadcrumb = [];
        this.bgColor = '#eee';
        this.fontSize = '18px';
        this.fontColor = '#0275d8';
        this.lastLinkColor = '#000';
        this.symbol = ' / ';
        this.breadCrumbData();
    }
    ngOnInit() {
        this.ng7MatBreadcrumbService.breadcrumbLabels.subscribe((labelData) => {
            for (const label in labelData) {
                if (labelData.hasOwnProperty(label)) {
                    this.breadcrumb.map((crumb) => {
                        const labelParams = crumb.label.match(/[^{{]+(?=\}})/g);
                        if (labelParams) {
                            for (const labelParam of labelParams) {
                                const dynamicData = labelData[label];
                                if (labelParam === label) {
                                    crumb.label = crumb.label.replace('{{' + labelParam + '}}', dynamicData);
                                }
                            }
                        }
                    });
                }
            }
        });
        this.ng7MatBreadcrumbService.newBreadcrumb.subscribe((breadcrumb) => {
            this.updateData(this.activatedRoute, breadcrumb);
        });
    }
    breadCrumbData() {
        this.router.events
            .pipe(filter(event => event instanceof NavigationEnd))
            .pipe(map(() => this.activatedRoute))
            .pipe(map((route) => {
            while (route.firstChild) {
                route = route.firstChild;
            }
            return route;
        }))
            .pipe(filter(route => route.outlet === PRIMARY_OUTLET))
            .subscribe(route => {
            this.params = route.snapshot.params;
            this.updateData(route, null);
        });
    }
    updateData(route, newBreadcrumb) {
        if (route.snapshot.data.breadcrumb || newBreadcrumb) {
            const data = route.snapshot.data.breadcrumb ? route.snapshot.data.breadcrumb : newBreadcrumb;
            const breadcrumb = (JSON.parse(JSON.stringify(data)));
            breadcrumb.map((crumb) => {
                const urlChunks = crumb.url.split('/');
                for (const chunk of urlChunks) {
                    if (chunk.includes(':')) {
                        const paramID = chunk.replace(':', '');
                        const routerParamID = this.params[paramID];
                        crumb.url = crumb.url.replace(`:${paramID}`, routerParamID);
                    }
                }
                const labelParams = crumb.label.match(/[^{{]+(?=\}})/g);
                if (labelParams) {
                    for (const labelParam of labelParams) {
                        const routerParamID = this.params[labelParam.trim()];
                        if (routerParamID) {
                            crumb.label = crumb.label.replace('{{' + labelParam + '}}', routerParamID);
                        }
                        else {
                        }
                    }
                }
            });
            this.breadcrumb = breadcrumb;
        }
        else {
            this.breadcrumb = [];
        }
    }
};
MatBreadcrumbComponent.ɵfac = function MatBreadcrumbComponent_Factory(t) { return new (t || MatBreadcrumbComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Router), ɵngcc0.ɵɵdirectiveInject(MatBreadcrumbService)); };
MatBreadcrumbComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatBreadcrumbComponent, selectors: [["lib-mat-breadcrumb"]], inputs: { bgColor: "bgColor", fontSize: "fontSize", fontColor: "fontColor", lastLinkColor: "lastLinkColor", symbol: "symbol" }, decls: 2, vars: 4, consts: [[1, "mat-bread-crumb", 3, "ngStyle"], ["class", "mat-bread-crumb-list", 4, "ngIf"], [1, "mat-bread-crumb-list"], [1, "mat-bread-crumb-spacer"], [4, "ngFor", "ngForOf"], ["class", "mat-bread-crumb-list-item", 3, "routerLink", "ngStyle", 4, "ngIf"], ["class", "mat-bread-crumb-list-item", 3, "ngStyle", 4, "ngIf"], [4, "ngIf"], [1, "mat-bread-crumb-list-item", 3, "routerLink", "ngStyle"], [1, "mat-bread-crumb-list-item", 3, "ngStyle"]], template: function MatBreadcrumbComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-toolbar", 0);
        ɵngcc0.ɵɵtemplate(1, MatBreadcrumbComponent_mat_list_1_Template, 4, 1, "mat-list", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(2, _c2, ctx.bgColor));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.breadcrumb.length);
    } }, directives: [ɵngcc2.MatToolbar, ɵngcc3.NgStyle, ɵngcc3.NgIf, ɵngcc4.MatList, ɵngcc4.MatListItem, ɵngcc3.NgForOf, ɵngcc1.RouterLinkWithHref], styles: [".mat-bread-crumb[_ngcontent-%COMP%]{height:30px;background-color:#f1efeb}.mat-bread-crumb-list[_ngcontent-%COMP%]{padding-bottom:10px}.mat-bread-crumb-list-item[_ngcontent-%COMP%]{font-size:15px}.mat-bread-crumb-spacer[_ngcontent-%COMP%]{margin-left:-20px}"] });
MatBreadcrumbComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: Router },
    { type: MatBreadcrumbService }
];
__decorate([
    Input()
], MatBreadcrumbComponent.prototype, "bgColor", void 0);
__decorate([
    Input()
], MatBreadcrumbComponent.prototype, "fontSize", void 0);
__decorate([
    Input()
], MatBreadcrumbComponent.prototype, "fontColor", void 0);
__decorate([
    Input()
], MatBreadcrumbComponent.prototype, "lastLinkColor", void 0);
__decorate([
    Input()
], MatBreadcrumbComponent.prototype, "symbol", void 0);

let MatBreadcrumbModule = class MatBreadcrumbModule {
};
MatBreadcrumbModule.ɵfac = function MatBreadcrumbModule_Factory(t) { return new (t || MatBreadcrumbModule)(); };
MatBreadcrumbModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatBreadcrumbModule });
MatBreadcrumbModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            RouterModule,
            CommonModule,
            BrowserAnimationsModule,
            MatToolbarModule,
            MatListModule
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatBreadcrumbService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatBreadcrumbComponent, [{
        type: Component,
        args: [{
                selector: 'lib-mat-breadcrumb',
                template: `
  <mat-toolbar class="mat-bread-crumb" [ngStyle]="{'background-color': bgColor}">
  <mat-list class="mat-bread-crumb-list" *ngIf="breadcrumb.length">
      <mat-list-item>
          <span class="mat-bread-crumb-spacer">
              <span *ngFor="let item of breadcrumb; let i = index">
                  <a *ngIf="item?.url" [routerLink]="item?.url" class="mat-bread-crumb-list-item" [ngStyle]="{'font-size': fontSize}" [ngStyle]="{'color': fontColor}">{{ item.label }}</a>
                  <span *ngIf="!item?.url" class="mat-bread-crumb-list-item" [ngStyle]="{'font-size': fontSize}"  [ngStyle]="{'color': lastLinkColor}">{{ item.label }}</span>
                  <span *ngIf="breadcrumb.length !== i+1">{{symbol}}</span>
              </span>
          </span>
      </mat-list-item>
  </mat-list>
</mat-toolbar>
  `,
                styles: [".mat-bread-crumb{height:30px;background-color:#f1efeb}.mat-bread-crumb-list{padding-bottom:10px}.mat-bread-crumb-list-item{font-size:15px}.mat-bread-crumb-spacer{margin-left:-20px}"]
            }]
    }], function () { return [{ type: ɵngcc1.ActivatedRoute }, { type: ɵngcc1.Router }, { type: MatBreadcrumbService }]; }, { bgColor: [{
            type: Input
        }], fontSize: [{
            type: Input
        }], fontColor: [{
            type: Input
        }], lastLinkColor: [{
            type: Input
        }], symbol: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatBreadcrumbModule, { declarations: function () { return [MatBreadcrumbComponent]; }, imports: function () { return [RouterModule,
        CommonModule,
        BrowserAnimationsModule,
        MatToolbarModule,
        MatListModule]; }, exports: function () { return [MatBreadcrumbComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatBreadcrumbModule, [{
        type: NgModule,
        args: [{
                declarations: [MatBreadcrumbComponent],
                imports: [
                    RouterModule,
                    CommonModule,
                    BrowserAnimationsModule,
                    MatToolbarModule,
                    MatListModule
                ],
                exports: [MatBreadcrumbComponent]
            }]
    }], null, null); })();

/*
 * Public API Surface of mat-breadcrumb
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MatBreadcrumbComponent, MatBreadcrumbModule, MatBreadcrumbService };

//# sourceMappingURL=mat-breadcrumb.js.map