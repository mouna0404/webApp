import { __decorate, __values } from "tslib";
import { Component, Input } from '@angular/core';
import { MatBreadcrumbService } from './mat-breadcrumb.service';
import { ActivatedRoute, Router, NavigationEnd, PRIMARY_OUTLET, RoutesRecognized } from '@angular/router';
import { filter } from 'rxjs/operators';
import { map } from 'rxjs/internal/operators';
var MatBreadcrumbComponent = /** @class */ (function () {
    function MatBreadcrumbComponent(activatedRoute, router, ng7MatBreadcrumbService) {
        this.activatedRoute = activatedRoute;
        this.router = router;
        this.ng7MatBreadcrumbService = ng7MatBreadcrumbService;
        this.breadcrumb = [];
        this.bgColor = '#eee';
        this.fontSize = '18px';
        this.fontColor = '#0275d8';
        this.lastLinkColor = '#000';
        this.symbol = ' / ';
        this.breadCrumbData();
    }
    MatBreadcrumbComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.ng7MatBreadcrumbService.breadcrumbLabels.subscribe(function (labelData) {
            var _loop_1 = function (label) {
                if (labelData.hasOwnProperty(label)) {
                    _this.breadcrumb.map(function (crumb) {
                        var e_1, _a;
                        var labelParams = crumb.label.match(/[^{{]+(?=\}})/g);
                        if (labelParams) {
                            try {
                                for (var labelParams_1 = (e_1 = void 0, __values(labelParams)), labelParams_1_1 = labelParams_1.next(); !labelParams_1_1.done; labelParams_1_1 = labelParams_1.next()) {
                                    var labelParam = labelParams_1_1.value;
                                    var dynamicData = labelData[label];
                                    if (labelParam === label) {
                                        crumb.label = crumb.label.replace('{{' + labelParam + '}}', dynamicData);
                                    }
                                }
                            }
                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                            finally {
                                try {
                                    if (labelParams_1_1 && !labelParams_1_1.done && (_a = labelParams_1.return)) _a.call(labelParams_1);
                                }
                                finally { if (e_1) throw e_1.error; }
                            }
                        }
                    });
                }
            };
            for (var label in labelData) {
                _loop_1(label);
            }
        });
        this.ng7MatBreadcrumbService.newBreadcrumb.subscribe(function (breadcrumb) {
            _this.updateData(_this.activatedRoute, breadcrumb);
        });
    };
    MatBreadcrumbComponent.prototype.breadCrumbData = function () {
        var _this = this;
        this.router.events
            .pipe(filter(function (event) { return event instanceof NavigationEnd; }))
            .pipe(map(function () { return _this.activatedRoute; }))
            .pipe(map(function (route) {
            while (route.firstChild) {
                route = route.firstChild;
            }
            return route;
        }))
            .pipe(filter(function (route) { return route.outlet === PRIMARY_OUTLET; }))
            .subscribe(function (route) {
            _this.params = route.snapshot.params;
            _this.updateData(route, null);
        });
    };
    MatBreadcrumbComponent.prototype.updateData = function (route, newBreadcrumb) {
        var _this = this;
        if (route.snapshot.data.breadcrumb || newBreadcrumb) {
            var data = route.snapshot.data.breadcrumb ? route.snapshot.data.breadcrumb : newBreadcrumb;
            var breadcrumb = (JSON.parse(JSON.stringify(data)));
            breadcrumb.map(function (crumb) {
                var e_2, _a, e_3, _b;
                var urlChunks = crumb.url.split('/');
                try {
                    for (var urlChunks_1 = __values(urlChunks), urlChunks_1_1 = urlChunks_1.next(); !urlChunks_1_1.done; urlChunks_1_1 = urlChunks_1.next()) {
                        var chunk = urlChunks_1_1.value;
                        if (chunk.includes(':')) {
                            var paramID = chunk.replace(':', '');
                            var routerParamID = _this.params[paramID];
                            crumb.url = crumb.url.replace(":" + paramID, routerParamID);
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (urlChunks_1_1 && !urlChunks_1_1.done && (_a = urlChunks_1.return)) _a.call(urlChunks_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                var labelParams = crumb.label.match(/[^{{]+(?=\}})/g);
                if (labelParams) {
                    try {
                        for (var labelParams_2 = __values(labelParams), labelParams_2_1 = labelParams_2.next(); !labelParams_2_1.done; labelParams_2_1 = labelParams_2.next()) {
                            var labelParam = labelParams_2_1.value;
                            var routerParamID = _this.params[labelParam.trim()];
                            if (routerParamID) {
                                crumb.label = crumb.label.replace('{{' + labelParam + '}}', routerParamID);
                            }
                            else {
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (labelParams_2_1 && !labelParams_2_1.done && (_b = labelParams_2.return)) _b.call(labelParams_2);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            });
            this.breadcrumb = breadcrumb;
        }
        else {
            this.breadcrumb = [];
        }
    };
    MatBreadcrumbComponent.ctorParameters = function () { return [
        { type: ActivatedRoute },
        { type: Router },
        { type: MatBreadcrumbService }
    ]; };
    __decorate([
        Input()
    ], MatBreadcrumbComponent.prototype, "bgColor", void 0);
    __decorate([
        Input()
    ], MatBreadcrumbComponent.prototype, "fontSize", void 0);
    __decorate([
        Input()
    ], MatBreadcrumbComponent.prototype, "fontColor", void 0);
    __decorate([
        Input()
    ], MatBreadcrumbComponent.prototype, "lastLinkColor", void 0);
    __decorate([
        Input()
    ], MatBreadcrumbComponent.prototype, "symbol", void 0);
    MatBreadcrumbComponent = __decorate([
        Component({
            selector: 'lib-mat-breadcrumb',
            template: "\n  <mat-toolbar class=\"mat-bread-crumb\" [ngStyle]=\"{'background-color': bgColor}\">\n  <mat-list class=\"mat-bread-crumb-list\" *ngIf=\"breadcrumb.length\">\n      <mat-list-item>\n          <span class=\"mat-bread-crumb-spacer\">\n              <span *ngFor=\"let item of breadcrumb; let i = index\">\n                  <a *ngIf=\"item?.url\" [routerLink]=\"item?.url\" class=\"mat-bread-crumb-list-item\" [ngStyle]=\"{'font-size': fontSize}\" [ngStyle]=\"{'color': fontColor}\">{{ item.label }}</a>\n                  <span *ngIf=\"!item?.url\" class=\"mat-bread-crumb-list-item\" [ngStyle]=\"{'font-size': fontSize}\"  [ngStyle]=\"{'color': lastLinkColor}\">{{ item.label }}</span>\n                  <span *ngIf=\"breadcrumb.length !== i+1\">{{symbol}}</span>\n              </span>\n          </span>\n      </mat-list-item>\n  </mat-list>\n</mat-toolbar>\n  ",
            styles: [".mat-bread-crumb{height:30px;background-color:#f1efeb}.mat-bread-crumb-list{padding-bottom:10px}.mat-bread-crumb-list-item{font-size:15px}.mat-bread-crumb-spacer{margin-left:-20px}"]
        })
    ], MatBreadcrumbComponent);
    return MatBreadcrumbComponent;
}());
export { MatBreadcrumbComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LWJyZWFkY3J1bWIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbWF0LWJyZWFkY3J1bWIvIiwic291cmNlcyI6WyJsaWIvbWF0LWJyZWFkY3J1bWIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFVLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV6RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDMUcsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hDLE9BQU8sRUFBRSxHQUFHLEVBQVksTUFBTSx5QkFBeUIsQ0FBQztBQXFCeEQ7SUFVRSxnQ0FDVSxjQUE4QixFQUM5QixNQUFjLEVBQ2QsdUJBQTZDO1FBRjdDLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5QixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsNEJBQXVCLEdBQXZCLHVCQUF1QixDQUFzQjtRQVh2RCxlQUFVLEdBQWlCLEVBQUUsQ0FBQztRQUNyQixZQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ2pCLGFBQVEsR0FBRyxNQUFNLENBQUM7UUFDbEIsY0FBUyxHQUFHLFNBQVMsQ0FBQztRQUN0QixrQkFBYSxHQUFHLE1BQU0sQ0FBQztRQUN2QixXQUFNLEdBQUcsS0FBSyxDQUFDO1FBUXRCLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQseUNBQVEsR0FBUjtRQUFBLGlCQXNCQztRQXJCQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLFVBQUMsU0FBUztvQ0FDckQsS0FBSztnQkFDZCxJQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEVBQUU7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QUFLLEVBQUU7NkRBQXVCO0lBQ3RCO1FBQVIsS0FBSyxFQUFFO2lFQUF3QjtJQUN2QjtRQUFSLEtBQUssRUFBRTswREFBZ0I7SUFQYixzQkFBc0I7UUFuQmxDLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxvQkFBb0I7WUFDOUIsUUFBUSxFQUFFLHMyQkFjVDs7U0FFRixDQUFDO09BQ1csc0JBQXNCLENBNEZsQztJQUFELDZCQUFDO0NBQUEsQUE1RkQsSUE0RkM7U0E1Rlksc0JBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCcmVhZGNydW1iIH0gZnJvbSAnLi9icmVhZGNydW1iLm1vZGVsJztcbmltcG9ydCB7IE1hdEJyZWFkY3J1bWJTZXJ2aWNlIH0gZnJvbSAnLi9tYXQtYnJlYWRjcnVtYi5zZXJ2aWNlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlLCBSb3V0ZXIsIE5hdmlnYXRpb25FbmQsIFBSSU1BUllfT1VUTEVULCBSb3V0ZXNSZWNvZ25pemVkIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IG1hcCwgbWVyZ2VNYXAgfSBmcm9tICdyeGpzL2ludGVybmFsL29wZXJhdG9ycyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2xpYi1tYXQtYnJlYWRjcnVtYicsXG4gIHRlbXBsYXRlOiBgXG4gIDxtYXQtdG9vbGJhciBjbGFzcz1cIm1hdC1icmVhZC1jcnVtYlwiIFtuZ1N0eWxlXT1cInsnYmFja2dyb3VuZC1jb2xvcic6IGJnQ29sb3J9XCI+XG4gIDxtYXQtbGlzdCBjbGFzcz1cIm1hdC1icmVhZC1jcnVtYi1saXN0XCIgKm5nSWY9XCJicmVhZGNydW1iLmxlbmd0aFwiPlxuICAgICAgPG1hdC1saXN0LWl0ZW0+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJtYXQtYnJlYWQtY3J1bWItc3BhY2VyXCI+XG4gICAgICAgICAgICAgIDxzcGFuICpuZ0Zvcj1cImxldCBpdGVtIG9mIGJyZWFkY3J1bWI7IGxldCBpID0gaW5kZXhcIj5cbiAgICAgICAgICAgICAgICAgIDxhICpuZ0lmPVwiaXRlbT8udXJsXCIgW3JvdXRlckxpbmtdPVwiaXRlbT8udXJsXCIgY2xhc3M9XCJtYXQtYnJlYWQtY3J1bWItbGlzdC1pdGVtXCIgW25nU3R5bGVdPVwieydmb250LXNpemUnOiBmb250U2l6ZX1cIiBbbmdTdHlsZV09XCJ7J2NvbG9yJzogZm9udENvbG9yfVwiPnt7IGl0ZW0ubGFiZWwgfX08L2E+XG4gICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiFpdGVtPy51cmxcIiBjbGFzcz1cIm1hdC1icmVhZC1jcnVtYi1saXN0LWl0ZW1cIiBbbmdTdHlsZV09XCJ7J2ZvbnQtc2l6ZSc6IGZvbnRTaXplfVwiICBbbmdTdHlsZV09XCJ7J2NvbG9yJzogbGFzdExpbmtDb2xvcn1cIj57eyBpdGVtLmxhYmVsIH19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJicmVhZGNydW1iLmxlbmd0aCAhPT0gaSsxXCI+e3tzeW1ib2x9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvbWF0LWxpc3QtaXRlbT5cbiAgPC9tYXQtbGlzdD5cbjwvbWF0LXRvb2xiYXI+XG4gIGAsXG4gIHN0eWxlVXJsczogWycuL21hdC1icmVhZGNydW1iLmNvbXBvbmVudC5jc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBNYXRCcmVhZGNydW1iQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICBicmVhZGNydW1iOiBCcmVhZGNydW1iW10gPSBbXTtcbiAgQElucHV0KCkgYmdDb2xvciA9ICcjZWVlJztcbiAgQElucHV0KCkgZm9udFNpemUgPSAnMThweCc7XG4gIEBJbnB1dCgpIGZvbnRDb2xvciA9ICcjMDI3NWQ4JztcbiAgQElucHV0KCkgbGFzdExpbmtDb2xvciA9ICcjMDAwJztcbiAgQElucHV0KCkgc3ltYm9sID0gJyAvICc7XG4gIHBhcmFtczogeyBba2V5OiBzdHJpbmddOiBhbnk7IH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBhY3RpdmF0ZWRSb3V0ZTogQWN0aXZhdGVkUm91dGUsXG4gICAgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcixcbiAgICBwcml2YXRlIG5nN01hdEJyZWFkY3J1bWJTZXJ2aWNlOiBNYXRCcmVhZGNydW1iU2VydmljZVxuICApIHtcbiAgICB0aGlzLmJyZWFkQ3J1bWJEYXRhKCk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLm5nN01hdEJyZWFkY3J1bWJTZXJ2aWNlLmJyZWFkY3J1bWJMYWJlbHMuc3Vic2NyaWJlKChsYWJlbERhdGEpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGFiZWwgaW4gbGFiZWxEYXRhKSB7XG4gICAgICAgIGlmIChsYWJlbERhdGEuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgICAgICAgdGhpcy5icmVhZGNydW1iLm1hcCgoY3J1bWIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsUGFyYW1zID0gY3J1bWIubGFiZWwubWF0Y2goL1tee3tdKyg/PVxcfX0pL2cpO1xuICAgICAgICAgICAgaWYgKGxhYmVsUGFyYW1zKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgbGFiZWxQYXJhbSBvZiBsYWJlbFBhcmFtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNEYXRhID0gbGFiZWxEYXRhW2xhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxQYXJhbSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNydW1iLmxhYmVsID0gY3J1bWIubGFiZWwucmVwbGFjZSgne3snICsgbGFiZWxQYXJhbSArICd9fScsIGR5bmFtaWNEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5uZzdNYXRCcmVhZGNydW1iU2VydmljZS5uZXdCcmVhZGNydW1iLnN1YnNjcmliZSgoYnJlYWRjcnVtYjogQnJlYWRjcnVtYltdKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZURhdGEodGhpcy5hY3RpdmF0ZWRSb3V0ZSwgYnJlYWRjcnVtYik7XG4gICAgfSk7XG4gIH1cblxuICBicmVhZENydW1iRGF0YSgpOiB2b2lkIHtcbiAgICB0aGlzLnJvdXRlci5ldmVudHNcbiAgICAgIC5waXBlKGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpKVxuICAgICAgLnBpcGUobWFwKCgpID0+IHRoaXMuYWN0aXZhdGVkUm91dGUpKVxuICAgICAgLnBpcGUobWFwKChyb3V0ZSkgPT4ge1xuICAgICAgICB3aGlsZSAocm91dGUuZmlyc3RDaGlsZCkgeyByb3V0ZSA9IHJvdXRlLmZpcnN0Q2hpbGQ7IH1cbiAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgICAgfSkpXG4gICAgICAucGlwZShmaWx0ZXIocm91dGUgPT4gcm91dGUub3V0bGV0ID09PSBQUklNQVJZX09VVExFVCkpXG4gICAgICAuc3Vic2NyaWJlKHJvdXRlID0+IHtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSByb3V0ZS5zbmFwc2hvdC5wYXJhbXM7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YShyb3V0ZSwgbnVsbCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGF0YShyb3V0ZSwgbmV3QnJlYWRjcnVtYik6IHZvaWQge1xuICAgIGlmIChyb3V0ZS5zbmFwc2hvdC5kYXRhLmJyZWFkY3J1bWIgfHwgbmV3QnJlYWRjcnVtYikge1xuICAgICAgY29uc3QgZGF0YSA9IHJvdXRlLnNuYXBzaG90LmRhdGEuYnJlYWRjcnVtYiA/IHJvdXRlLnNuYXBzaG90LmRhdGEuYnJlYWRjcnVtYiA6IG5ld0JyZWFkY3J1bWI7XG4gICAgICBjb25zdCBicmVhZGNydW1iID0gKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpKTtcbiAgICAgIGJyZWFkY3J1bWIubWFwKChjcnVtYikgPT4ge1xuXG4gICAgICAgIGNvbnN0IHVybENodW5rcyA9IGNydW1iLnVybC5zcGxpdCgnLycpO1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHVybENodW5rcykge1xuICAgICAgICAgIGlmIChjaHVuay5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbUlEID0gY2h1bmsucmVwbGFjZSgnOicsICcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlclBhcmFtSUQgPSB0aGlzLnBhcmFtc1twYXJhbUlEXTtcbiAgICAgICAgICAgIGNydW1iLnVybCA9IGNydW1iLnVybC5yZXBsYWNlKGA6JHtwYXJhbUlEfWAsIHJvdXRlclBhcmFtSUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhYmVsUGFyYW1zID0gY3J1bWIubGFiZWwubWF0Y2goL1tee3tdKyg/PVxcfX0pL2cpO1xuICAgICAgICBpZiAobGFiZWxQYXJhbXMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGxhYmVsUGFyYW0gb2YgbGFiZWxQYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlclBhcmFtSUQgPSB0aGlzLnBhcmFtc1tsYWJlbFBhcmFtLnRyaW0oKV07XG4gICAgICAgICAgICBpZiAocm91dGVyUGFyYW1JRCkge1xuICAgICAgICAgICAgICBjcnVtYi5sYWJlbCA9IGNydW1iLmxhYmVsLnJlcGxhY2UoJ3t7JyArIGxhYmVsUGFyYW0gKyAnfX0nLCByb3V0ZXJQYXJhbUlEKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgICAgdGhpcy5icmVhZGNydW1iID0gYnJlYWRjcnVtYjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5icmVhZGNydW1iID0gW107XG4gICAgfVxuICB9XG5cblxuXG59XG4iXX0=